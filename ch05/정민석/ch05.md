# 트랜잭션

트랜잭션이란?

- 트랜잭션은 작업의 완전성을 보장해준다.
- 즉, 논리적인 작업 셋을 모두 완벽하게 처리 OR 처리 못할 경우 원상태로 복구하여 일부만 적용되는 현상을 막아준다.


## MySQL에서의 트랜잭션

트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을때만 의미있는 개념은 아니다.

하나의 논리적 작업 셋에 쿼리가 1개건 2개건 상관없이 트랜잭션을 사용하여 작업의 완전성을 보장할 수 있다.


### 트랜잭션 관점에서 InnoDB와 MyISAM 테이블의 차이

```sql
CREATE TABLE table_myisam (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
) ENGINE=MyISAM;

INSERT INTO table_myisam (id) VALUES (3);
```
```sql
CREATE TABLE table_innodb (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
) ENGINE=InnoDB;

INSERT INTO table_innodb (id) VALUES (3);
```

위와 같이 테스트 테이블에 레코드 1개를 삽입한 이후 AUTO_COMMIT을 활성화하고 다음 쿼리를 실행해본다.

```sql
SET AUTOCOMMIT = ON;

INSERT INTO table_myisam (id) VALUES (1), (2), (3);
INSERT INTO table_innodb (id) VALUES (1), (2), (3);

[23000][1062] Duplicate entry '3' for key 'table_myisam. PRIMARY'
[23000][1062] Duplicate entry '3' for key 'table_innodb. PRIMARY'

```
table_myisam 

| id |
| :--- |
| 1 |
| 2 |
| 3 |

table_innodb

| id |
| :--- |
| 3 |


두 문장 모두 PK 중복 오류로 쿼리가 실패하였는데 서로 다른 결과값을 조회할 수 있었다.
즉, MyISAM 테이블에 INSERT 쿼리가 실행되며 차례대로 1과 2를 저장하고 3을 저장하려는 순간 에러가 발생하였다.

반대로 InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만드는 트랜잭션의 원칙대로 INSERT 쿼리 실행 전 상태로 복구했다.

MyISAM 테이블에서 발생한 이러한 현상을 Partial Update라고 표현하며 정합성을 맞추는데 까다로워진다.

## 주의사항
트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다!

아래 예제를 통해 살펴보자
1. 처리 시작 
   2. DB 커넥션 생성
   3. 트랜잭션 시작  
4. 사용자의 로그인 여부 확인
5. 사용자의 글쓰기 내용 오류 여부 확인
6. 첨부로 업로드된 파일 확인 및 저장
7. 사용자 입력 내용 DB에 저장
8. 첨부파일 정보 DB에 저장
9. 저장된 내용 또는 기타 정보 DB에 조회
10. 게시물 등록에 대한 알림 메일 발송
11. 알림 메일 발송 이력 DB에 저장
    12. 트랜잭션 종료
    13. DB 커넥션 반납
14. 처리 완료


위 처리 절차 중 DB 트랜잭션 처리에 좋지 않은 영향을 미치는 부분을 나눠서 확인해보자

- DB 커넥션을 생성하는 코드를 1번과 2번 사이에 넣어둔 뒤 START TRANSACTION 명령으로 트랜잭션을 시작한다. 그리고 9번과 10번 사이에 COMMIT 후 커넥션을 종료한다.
- 실제 DB에 데이터를 저장하는 작업은 5번부터 시작되는데 2, 3, 4번의 절차가 아무리 빠르더라도 DB 트랜잭션에 포함시킬 필요가 없다.
- 트랜잭션 커넥션은 일반적으로 개수가 제한적이어서 커넥션 소유 시간이 길어질 수록 여유 커넥션의 개수는 줄어들 것이다.

- 더 큰 위험은 8번 작업이다. 메일 전송이나 파일 전송 작업 등 네트워크를 통해 원격 서버와 연결하는 작업은 트랜잭션에 포함시키지 않는 것이 좋다!
- 만약 프로그램이 실행되는 동안 메일 서버에 문제가 생긴다면? 웹 서버 뿐 아니라 DB 서버까지 위험해질 수 있다.

위 처리 절차에는 DB 작업이 크게 4개가 있다.
1. 사용자가 입력한 정보를 저장하는 5, 6번 작업은 반드시 하나로 묶어야한다.
2. 7번 작업은 저장된 데이터를 단순 확인 및 조회이므로 반드시 넣을 필요는 없다.
3. 9번 작업은 성격이 ㄷ다르기에 이전 트랜잭션(5, 6번)과 묶지 않아도 무방할 수 있다. 따라서 이러한 작업은 별도 트랜잭션으로 분리하는 것이 좋다.
4. 추가로 7번이 단순 조회라면 트랜잭션을 사용하지 않아도 된다.

따라서 위 처리 절차를 다음과 같이 변경할 수 있다.

1. 처리 시작
2. 사용자의 로그인 여부 확인 
3. 사용자의 글쓰기 내용 오류 여부 확인 
4. 첨부로 업로드된 파일 확인 및 저장
   5. DB 커넥션 생성
   6. 트랜잭션 시작
7. 사용자 입력 내용 DB에 저장
8. 첨부파일 정보 DB에 저장
   9. 트랜잭션 종료(COMMIT)
10. 저장된 내용 또는 기타 정보 DB에 조회
11. 게시물 등록에 대한 알림 메일 발송
    12. 트랜잭션 시작
13. 알림 메일 발송 이력 DB에 저장
    14. 트랜잭션 종료
    15. DB 커넥션 반납
16. 처리 완료

구현하고자하는 업무 특성에 따라 다를 수 있지만 결국 핵심은 아래와 같다.

- 프로그램의 코드가 DB 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화 해야한다.
- 네트워크 작업이 있는 경우 반드시 트랜잭션에서 배제해야한다!

-> 위와 같은 실수가 DB 서버에 부하를 주고 위험한 상태에 빠질 수 있는 경우가 빈번히 발생한다.



# MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 크게 아래와 같이 나눌 수 있다.

- 스토리지 엔진 레벨
- MySQL 엔진 레벨
  - (MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분)

MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.

MySQL 엔진에서는 테이블 데이터 동기화를 위한 **테이블 락** 이외에도 테이블 구조를 잠그는 **메타데이터 락** 그리고 사용자 필요에 맞게 사용할 수 있는 **네임드 락**을 제공한다.


## 글로벌 락

**글로벌락**은 **FLUSH TABLES WITH READ LOCK** 명령으로 획득할 수 있으며 **MySQL에서 제공하는 잠금 중 가장 범위가 크다.**

일단 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SEELECT를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때 까지 해당 문장이 대기 상태로 남는다.

미치는 영향: MySQL 서버 전체 테이블, 데이터베이스가 다르더라도 영향을 미침

FLUSH TABLES WITH READ LOCK은 모든 변경 작업을 멈추는데 InnoDB가 기본 스토리지 엔진이 되면서 조금 더 가벼운 글로벌 락의 필요성이 생겼다.

XtraBackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됐다.

```sql
LOCK INSTANCE FOR BACKUP;
-- 백업 실행
UNLOCK INSTANCE;
```

특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블 스키마나 사용자 인증 관련 정보를 변경할 수 없게 된다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE, OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

하지만 백업 락은 일반적인 테이블의 데이터 변경은 허용된다. 


## 테이블 락
테이블 락(Table Lock)은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

### 명시적 획득
명시적으로는 "LOCK TABLES table_name [READ|WRITE]" 명령으로 획득할 수 있다.

테이블 락은 MyISAM 뿐만 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정 가능하다.
명시적 획득 락은 UNLOCK TABLES 명령으로 해제할 수 있다.

단, 명시적 테이블 락은 특별한 상황이 아니라면 애플리케이션에서 사용할 필요가 거의 없는데, 글로벌 락과 마찬가지로 온라인 작업에 상당한 영향을 미치기 때문이다.

### 묵시적 획득
MyISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.

MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후 즉시 잠금을 해제하는 형태로 사용된다.
즉, 쿼리가 실행되는 동안 자동 획득 이후 자동 해제된다. 

하지만 InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반 잠금을 제공하기에 단순 데이터 변경 쿼리로 묵시적 테이블 락이 설정되지 않는다.
자세히는 테이블 락이 설정되지만, 대부분 DML 쿼리에서는 무시되고 DDL에만 영향을 미친다.

## 네임드 락
네임드 락은 GET_LOCK() 함수를 사용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
이 락의 특징은 대상이 테이블, 레코드 또는 AUTO_INCREMENT와 같이 객체가 아니라는 것이다.

단순 사용자가 지정한 문자열(String)에 대해 획득하고 반납하는 잠금이며 자주 사용되지는 않는다.

예시로 데이터베이스 서버 1대에 5대의 웹 서버가 접속해서 서비스하는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야하는 요건처럼 여러 클라이언트가 상호 동기화해야할 때 네임드락을 이용하여 쉽게 해결할 수 있다.

```sql
SELECT GET_LOCK('lock_name', 10); 
--(10초 대기)

-- "lock_name"이라는 문자열에 락이 걸려있는지 확인
SLECT IS_FREE_LOCK('lock_name');

-- 락 해제
SELECT RELEASE_LOCK('lock_name');

-- 위 함수 모두 정상적으로 락을 획득하거나 해제한 경우에는 1, 아니면 NULL or 0을 반환한다.
```

또한 많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 쓸 수 있다.
batch job처럼 대량 레코드를 변경하는 쿼리는 데드락을 유발할 수 있는데 실행 시간을 분산하거나 코드를 수정하여 데드락을 최소화할 수 있지만 간단하지도 않고 best practice도 아니다.

이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류하여 네임드락을 거고 쿼리를 실행하면 간단히 해결할 수 있다.

MySQL 8.0부터는 네임드 락을 중첩하여 사용할 수 있고 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제할 수도 있다.

```sql
SELECT GET_LOCK('lock_name_1', 10);

SELECT GET_LOCK('lock_name_2', 10);

SELECT REALEASE_LOCK('lock_name_1');
SELECT REALEASE_LOCK('lock_name_2');

-- 동시에 모두 해제
SELECT RELEASE_ALL_LOCKS();
```

## 메타데이터 락
메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금이다.
명시적으로 획득하거나 해제할 수 있는 것이 아니고 "RENAME TABLE table_a to table_b"와 같이 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
RENAME TABLE 명령의 경우 원본 이름과 변경ㄷ될 이름 두 개 모두 한꺼번에 잠금을 설정하며 실시간으로 테이블을 바꿔야하는 요건이 batch job에서 자주 발생하는데 아래 예제로 살펴보겠다.

```sql
-- batch job에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터 생성
-- 랭킹 배치가 완료도디면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업하고 새로 만들어질 테이블을 서비스용으로 대체
RENAME TABLE rank TO rank_backup, rank_new TO rank;
```

위와 같이 하나의 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 "Table not found rank" 같은 상황을 발생시키지 않고 적용하는 것이 가능하다.
하지만 위 문장을 2개로 나눠서 실행하면 짧은 시간이지만 rank 테이블이 존재하지 않는 순간이 생기며 그 순간 "Table not found rank"라는 오류가 발생한다.

때로는 메타데이터 락과 InnoDB의 트랜잭션을 동시 사용해야할 케이스도 있다.

예를 들어 로그 테이블이 있었는데 테이블 구조를 변경해야한다면 Online DDL을 사용하여 변경할 수 있지만 시간이 오래걸린다면 언두 로그 증가, 버퍼 크기 등 고민해야할 문제가 생긴닫.
더 큰 문제는 DDL이 단일 스레드로 동작하기에 많은 시간이 소요될 것이다.

이때는 새로운 구조의 테이블을 생성하고 최근 데이터 까지 PK를 범위별로 나누어서 여러 스레드로 빠르게 복사한다.

그리고 나머지 데이터는 트랜잭션과 테이블 잠금, RENAME TABLE을 조합하여 처리한다.